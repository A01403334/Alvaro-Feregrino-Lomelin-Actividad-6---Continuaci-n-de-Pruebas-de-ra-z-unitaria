# -*- coding: utf-8 -*-
"""Actividad 6 - Continuación de Pruebas de raíz unitaria

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VUibSJVAchJojkYfDQUwHvT2c61uAzQ8
"""

import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf
from statsmodels.tsa.seasonal import seasonal_decompose

# Set random seed for reproducibility
np.random.seed(42)

# Define date range and stocks
start_date = "2019-11-29"
end_date = "2025-04-08"
stocks = ['AAPL', 'BAC', 'GOOG', 'KO']

# Fetch stock data
print("Downloading stock data...")
data = yf.download(stocks, start=start_date, end=end_date, progress=False)

# Validate data
if data.empty:
    raise ValueError("No data retrieved from yfinance. Check tickers or connection.")

# Use 'Adj Close' or 'Close'
price_data = data['Adj Close'] if 'Adj Close' in data.columns else data['Close']
if 'Adj Close' not in data.columns:
    print("Warning: Using 'Close' instead of 'Adj Close'.")

# Handle missing data
price_data = price_data.fillna(method='ffill').dropna()

# Calculate returns
returns = price_data.pct_change().dropna()

# Function to simulate random walk with seasonality
def random_walk_simulation(price_series, steps, seasonal_component=None):
    returns = price_series.pct_change().dropna()
    mean_return = returns.mean()
    std_return = returns.std()
    daily_returns = np.random.normal(loc=mean_return, scale=std_return, size=steps)
    if seasonal_component is not None:
        daily_returns += seasonal_component
    random_walk = price_series.iloc[0] * np.cumprod(1 + daily_returns)
    return random_walk

# ADF test function
def unit_root_test(series, stock_name, data_type="prices"):
    result = adfuller(series.dropna())
    print(f'\nADF Test for {stock_name} ({data_type}):')
    print(f'ADF Statistic: {result[0]:.4f}, p-value: {result[1]:.4f}')
    print(f"Stationary: {'Yes' if result[1] < 0.05 else 'No'}")

# Seasonality check
def check_seasonality(series, stock_name, period=252):
    decomposition = seasonal_decompose(series.dropna(), model='additive', period=period)
    seasonal = decomposition.seasonal
    seasonal_strength = seasonal.std() / series.std()
    print(f'\nSeasonality for {stock_name}: Strength = {seasonal_strength:.4f}')
    print(f"Seasonal: {'Yes' if seasonal_strength > 0.1 else 'No'}")
    return seasonal / series.mean()  # Normalized seasonal component

# Plotting function
def plot_analysis(price_data, returns, stocks):
    fig, axes = plt.subplots(len(stocks), 3, figsize=(15, 4 * len(stocks)), sharex='col')

    for i, stock in enumerate(stocks):
        # Actual vs Random Walk
        seasonal = check_seasonality(price_data[stock], stock)
        seasonal_cycle = np.tile(seasonal.values, int(np.ceil(len(price_data) / len(seasonal))))[:len(price_data)]
        rw = random_walk_simulation(price_data[stock], len(price_data), seasonal_cycle)
        axes[i, 0].plot(price_data.index, price_data[stock], label='Actual', color='blue')
        axes[i, 0].plot(price_data.index, rw, label='Random Walk', color='orange', linestyle='--')
        axes[i, 0].set_title(f'{stock}: Price vs Random Walk')
        axes[i, 0].legend()
        axes[i, 0].grid(True)

        # Correlogram of Returns
        plot_acf(returns[stock].dropna(), lags=20, ax=axes[i, 1])
        axes[i, 1].set_title(f'{stock}: ACF of Returns')

        # Returns Plot
        axes[i, 2].plot(returns.index, returns[stock], color='green')
        axes[i, 2].set_title(f'{stock}: Daily Returns')
        axes[i, 2].grid(True)

    plt.tight_layout()
    plt.savefig('stock_analysis.png')
    plt.show()

# Analyze each stock
print("\n=== Time Series Analysis ===")
for stock in stocks:
    unit_root_test(price_data[stock], stock, "prices")
    unit_root_test(returns[stock], stock, "returns")

# Generate plots
plot_analysis(price_data, returns, stocks)